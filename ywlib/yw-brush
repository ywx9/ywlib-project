#pragma once
#include <yw-com.hpp>

namespace yw {

/// class to represent a solid color brush
class brush : public comptr<::ID2D1SolidColorBrush> {
  using base = comptr<::ID2D1SolidColorBrush>;
public:
  static const brush black, white, red, yellow, green, blue;
  explicit operator bool() const noexcept { return base::operator bool(); }
  ::ID2D1SolidColorBrush* operator->() const noexcept { return base::get(); }
  brush() noexcept = default;
  /// initializes a brush with a color
  explicit brush(const yw::color& c, const source& _ = {}) {
    auto hr = main::d2d_context->CreateSolidColorBrush(&c, nullptr, &base::get());
    if (hr != 0) throw std::runtime_error(format("Error {:x}: {} <- {}", hr, source{}, _));
  }
  /// sets the brush color; or initializes with the color.
  void color(const yw::color& c) { operator bool() ? void(base::get()->SetColor(&c)) : void(*this = brush(c)); }
  /// gets the brush color
  yw::color color() const { return operator bool() ? bitcast<yw::color>(base::get()->GetColor()) : yw::color{}; }
};

inline const brush brush::black{color::black};
inline const brush brush::white{color::white};
inline const brush brush::red{color::red};
inline const brush brush::yellow{color::yellow};
inline const brush brush::green{color::green};
inline const brush brush::blue{color::blue};

/// class to represent a text format
class text_format : public comptr<::IDWriteTextFormat> {
  using base = comptr<::IDWriteTextFormat>;
public:
  explicit operator bool() const noexcept { return base::operator bool(); }
  ::IDWriteTextFormat* operator->() const noexcept { return base::get(); }
  text_format() noexcept = default;
  template<stringable S> text_format(S&& Name, arithmetic auto Size, const source& _ = {}) {
    auto name = unicode<wchar_t>(static_cast<S&&>(Name));
    auto hr   = os::dw_factory->CreateTextFormat(name.data(), nullptr, 400, 0, 5, float(Size), L"", &base::get());
    if (hr != 0) throw std::runtime_error(format("Error {:x}: {} <- {}", hr, source{}, _));
    base::get()->SetTextAlignment(0);
  }
  /// sets the alignment of the text
  void set_alignment(int MinusZeroPlus) const noexcept {
    int alignment = int(MinusZeroPlus == 0) * 2 + int(MinusZeroPlus > 0);
    base::get()->SetTextAlignment(DWRITE_TEXT_ALIGNMENT(alignment));
  }
};

/// class to represent a bitmap for 2D drawing
class bitmap : public comptr<::ID2D1Bitmap1> {
  using base                              = comptr<::ID2D1Bitmap1>;
  static constexpr auto pixel_format      = D2D1_PIXEL_FORMAT{DXGI_FORMAT_R8G8B8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED};
  static constexpr auto bitmap_properties = D2D1_BITMAP_PROPERTIES1{pixel_format, 96.f, 96.f, D2D1_BITMAP_OPTIONS_TARGET, nullptr};
public:
  class drawing {
    inline static ::ID2D1Bitmap1* _bitmap = nullptr;
    drawing(const drawing&)               = delete;
    drawing& operator=(const drawing&)    = delete;
  public:
    explicit operator bool() const noexcept { return bool(_bitmap); }
    ~drawing() { _bitmap ? void((_bitmap = nullptr, main::d2d_context->EndDraw())) : void(); }
    /// begins drawing on the bitmap
    drawing(::ID2D1Bitmap1* b, const source& _ = {}) {
      if (_bitmap) throw std::logic_error(format("{}: already drawing", _));
      if (!b) throw std::logic_error(format("{}: bitmap is null", _));
      _bitmap = b, main::d2d_context->SetTarget(b), main::d2d_context->BeginDraw();
    }
    /// fills the bitmap with a color and begins drawing
    drawing(::ID2D1Bitmap1* b, const color& c, const source& _ = {}) : drawing(b, _) { main::d2d_context->Clear(&c); }
    /// ends drawing
    void close(const source& _ = {}) {
      if (!_bitmap) throw std::logic_error(format("{}: not drawing", _));
      _bitmap = nullptr, main::d2d_context->EndDraw(), main::d2d_context->SetTarget(nullptr);
    }
    /// clears the bitmap with a color
    void clear(const color& c) { main::d2d_context->Clear(&c); }
    /// draws a bitmap; fill the target
    void bitmap(ID2D1Bitmap1* Bitmap, float Opacity = 1.0f) {
      main::d2d_context->DrawBitmap(Bitmap, nullptr, Opacity, D2D1_INTERPOLATION_MODE_LINEAR, nullptr);
    }
    /// draws a bitmap; with destination and clipping rectangle
    void bitmap(ID2D1Bitmap1* b, const vector4<float>& dest_xywh, const vector4<float>& clip_xywh, float opacity = 1.0f) {
      main::d2d_context->DrawBitmap(b, &dest_xywh, opacity, D2D1_INTERPOLATION_MODE_LINEAR, &clip_xywh);
    }
    /// draws a bitmap; with destination rectangle
    void bitmap(ID2D1Bitmap1* b, const vector4<float>& dest_xywh, float opacity = 1.0f) {
      main::d2d_context->DrawBitmap(b, &dest_xywh, opacity, D2D1_INTERPOLATION_MODE_LINEAR, nullptr);
    }
    /// draws text
    template<stringable S> void text(
      S&& Str, const vector4<float>& rect, //
      IDWriteTextFormat* Format = text_format::default_, ID2D1Brush* Brush = brush::black) {
      auto str = unicode<wchar_t>(static_cast<S&&>(Str));
      main::d2d_context->DrawText(str.data(), int(str.size()), Format, &rect, Brush, 2, 0);
    }
    /// draws text
    template<stringable S> void text(
      S&& Str, const vector2<float>& xy, const vector2<float>& wh, //
      IDWriteTextFormat* Format = text_format::default_, ID2D1Brush* Brush = brush::black) {
      auto str  = unicode<wchar_t>(static_cast<S&&>(Str));
      auto rect = vector4<float>(xy.x, xy.y, xy.x + wh.x, xy.y + wh.y);
      main::d2d_context->DrawText(str.data(), int(str.size()), Format, &rect, Brush, 2, 0);
    }
    /// draws a line
    void line(const vector2<float>& p1, const vector2<float>& p2, ID2D1Brush* Brush = brush::black, float Width = 1.0f) {
      main::d2d_context->DrawLine({p1.x, p1.y}, {p2.x, p2.y}, Brush, Width);
    }
};
virtual ~bitmap() noexcept {}
explicit operator bool() const noexcept { return base::operator bool(); }
::ID2D1Bitmap1* operator->() const noexcept { return base::get(); }
bitmap() noexcept = default;
bitmap(const vector2<int>& wh, const source& _ = {}) {
  auto hr = main::d2d_context->CreateBitmap({wh.x, wh.y}, nullptr, 0, &bitmap_properties, &base::get());
  if (hr != 0) throw std::runtime_error(format("Error {:x}: {} <- {}", hr, source{}, _));
}
bitmap(const path& File, const source& _ = {}) {
  comptr<IWICBitmapDecoder> decoder{};
  auto hr = main::wic_factory->CreateDecoderFromFilename(File.c_str(), nullptr, 0x80000000, {}, &decoder.get());
  if (hr != 0) throw std::runtime_error(format("{}: CreateDecoderFromFilename failed: {:x}", _, hr));
  comptr<IWICBitmapFrameDecode> frame{};
  hr = decoder->GetFrame(0, &frame.get());
  if (hr != 0) throw std::runtime_error(format("{}: IWICBitmapDecoder::GetFrame failed: {:x}", _, hr));
  vector2<int> wh;
  hr = frame->GetSize(&wh.x, &wh.y);
  if (hr != 0) throw std::runtime_error(format("{}: IWICBitmapFrameDecode::GetSize failed: {:x}", _, hr)); // clang-format off
    GUID pixel_format, guid = GUID{0x3cc4a650, 0xa527, 0x4d37, {0xa9, 0x16, 0x31, 0x42, 0xc7, 0xeb, 0xed, 0xba}}; // clang-format on
  hr = frame->GetPixelFormat(&pixel_format);
  if (hr != 0) throw std::runtime_error(format("{}: IWICBitmapFrameDecode::GetPixelFormat failed: {:x}", _, hr));
  comptr<IWICFormatConverter> fc;
  hr = main::wic_factory->CreateFormatConverter(&fc.get());
  if (hr != 0) throw std::runtime_error(format("{}: CreateFormatConverter failed: {:x}", _, hr));
  int can_convert{0};
  hr = fc->CanConvert(pixel_format, guid, &can_convert);
  if (hr != 0) throw std::runtime_error(format("{}: IWICFormatConverter::CanConvert failed: {:x}", _, hr));
  if (!can_convert) throw std::runtime_error(format("{}: IWICFormatConverter::CanConvert returns false", _));
  hr = fc->Initialize(frame, guid, WICBitmapDitherTypeErrorDiffusion, nullptr, 0, WICBitmapPaletteTypeMedianCut);
  if (hr != 0) throw std::runtime_error(format("{}: IWICFormatConverter::Initialize failed: {:x}", _, hr));
  main::d2d_context->CreateBitmapFromWicBitmap(fc, nullptr, &base::get());
}
/// starts drawing
os::drawing draw(const source& _ = {}) { return os::drawing(base::get(), _); }
/// starts drawing with clear color
os::drawing draw(const rgba& ClearColor, const source& _ = {}) { return os::drawing(base::get(), ClearColor, _); }
/// saves bitmap as a png or jpg
void to_file(const path& p, const source& _ = {}) { os::bitmap_to_file(base::get(), p, _); }
};
}
